#!/usr/bin/python

import com.kxw.python.fibo  # 导入包
import sys

# python python3-module.py 参数1 参数2
print('命令行参数如下:')
for i in sys.argv:
    print(i)

print('/n/nThe PYTHONPATH is', sys.path, '/n')


# 1、import sys引入python标准库中的sys.py模块；这是引入某一模块的方法。
# 2、sys.argv是一个包含命令行参数的列表。
# 3、sys.path包含了一个Python解释器自动查找所需模块的路径的列表。

'''当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？
这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找锁引入的模块。
这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。
搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量'''

'''sys.path输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。
因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。
了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。'''

# Python引用（import）文件夹下的py文件的方法,Python中比较特别,导入文件夹下的py文件,则这个目录下必须要有一个__init__.py文件才可
# <http://www.jb51.net/article/54323.htm>

com.kxw.python.fibo.fib(1000)
# 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
com.kxw.python.fibo.fib2(100)
# [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
com.kxw.python.fibo.__name__

'''如果你打算经常使用一个函数，你可以把它赋给一个本地的名称'''
fib = com.kxw.python.fibo.fib
fib(500)

'''深入模块
模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。
每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。
所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。
从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。
模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。
还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。'''

from com.kxw.python.fibo import fib, fib2
fib(500)

'''这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。
这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表'''
from com.kxw.python.fibo import *
fib(500)
'''这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。
大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。'''


# __name__属性
'''一个模块被另一个程序第一次引入时，其主程序将运行。
如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。'''

if __name__ == '__main__':
    print('程序自身在运行')
else:
    print('我来自另一模块')
'''每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入'''

# dir() 函数
'''内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回'''
dir(com.kxw.python.fibo)
# ['__name__', 'fib', 'fib2']

'''如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称'''
a = [1, 2, 3, 4, 5]
dir()  # 得到一个当前模块中定义的属性列表
# ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']

# 标准模块
'''Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的"库参考文档"）。
有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。
这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。
应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。
变量 sys.ps1 和 sys.ps2 定义了主提示符('>>> ')和副提示符('... ')所对应的字符串.'''


# 包
'''包是一种管理 Python 模块命名空间的形式，采用"点模块名称"。'''
'''在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。
目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。
最简单的情况，放一个空的 :file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。'''

'''用户可以每次只导入一个包里面的特定模块，比如:
import sound.effects.echo
这将会导入子模块:mod:song.effects.echo。 他必须使用全名去访问:
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
还有一种导入子模块的方法是:
from sound.effects import echo
这同样会导入子模块:mod:echo，并且他不需要那些冗长的前缀，所以他可以这样使用:
echo.echofilter(input, output, delay=0.7, atten=4)
还有一种变化就是直接导入一个函数或者变量:
from sound.effects.echo import echofilter
'''

# 从一个包中导入*
'''
设想一下，如果我们使用 from sound.effects import *会发生什么？
Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。
但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。
在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块:mod:echo还是:mod:Echo甚至:mod:ECHO。
（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。
为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。
导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。
作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码:'''

# __all__ = ["echo", "surround", "reverse"]

'''这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。
如果__all__真的而没有定义，那么使用from sound.effects import *这种语法的时候，就*不会*导入包:mod:sound.effects里的任何子模块。他只是把包:mod:sound.effects和它里面定义的所有内容导入进来（可能运行:file:__init__.py里定义的初始化代码）。
这会把 :file:__init__.py里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:'''

# ...

# <http://www.runoob.com/python3/python3-module.html>

